---
title: 《深入浅出node.js》读书笔记6-1网络编程
date: 2019-08-23 23:57:27
categories:
- 读书笔记
- 《深入浅出node.js》
tags:
- node
- 系统学习
description: TCP HTTP
---
Node是一个面向网络而生的平台，它具有事件驱动、无阻塞、单线程等特性，具备良好的可伸缩性，使它十分轻量，适合在分布式网络中扮演各种各样的角色。        
Node只需几行代码即可构建服务器，无需额外的容器。        
Node提供net、dgram、http、https4个模块，分别用于TCP、UDP、HTTP、HTTPS。适用于服务器和客户端。

## 构建TCP服务
TCP服务在网络应用中十分常见，目前大多数的应用都是基于TCP搭建而成。

### TCP
TCP全名为传输控制协议，在OSI模型中属于传输层协议。TCP协议是面向连接的协议，其显著的特征是在传输之前需要3次握手形成会话。只有形成会话之后，服务器端和客户端之间才能互相发送数据。        
![](http://img.aisss.top/FkDDxpAyose34YtA1Irp_19zri8A)

### 创建TCP服务器端
创建一个TCP服务端来接受网络请求
```JavaScript
var net = require('net');

var server = net.createServer(function(socket){
    // 新的连接
    socket.on('data', function(data){
        socket.write('你好')
    })

    socket.on('end', function() {
        console.log('连接断开')
    })
    socket.write("欢迎光临《深入浅出node.js》示例：\n"); 
})

server.listen(8124, function(){
    console.log('server bound');
})
```
通过net模块自行构建客户端进行会话，测试上面构建的TCP服务的代码，如下：
```Javascript
var net = require('net');
var client = net.connect({port: 8124}, function(){
    console.log('client connected');
    client.write('world!\r\n');
})

client.on('data', function(data){
    console.log(data.toString());
    client.end();
})

client.on('end', function(){
    console.log('client disconnected');
})
```

### TCP服务的事件
#### 1. 服务器事件   
对于通过`net.createServer()`创建的服务器而言，它是一个EventEmitter实例，它的自定义事件有如下几种：
- listening: 在调用`server.listen()`绑定端口或者Domain Socket后触发。
- connection: 每个客户端套接字连接到服务器时触发，简洁写法为通过`net.createServer()`的最后一个参数传递。
- close： 当服务器关闭时触发，在调用`server.close()`后，服务器将停止接受新的套接字连接，但保持当前存在但连接，等待所有连接都断开后，会触发该事件。
- error: 当服务器发送异常时，将会触发该事件。比如侦听一个使用中的端口，将会触发一个异常，如果不侦听error事件，服务器将会抛出异常。

#### 2. 连接事件
服务器可以同时与多个客户端保持连接，对于每个连接而言是典型的可读可写Stream对象。Stream对象可以用于服务队与客户端之间的通信，既可以通过data事件从一端读取另一端发来的数据，也可以通过`write()`方法从一端向另一端发送数据。它具有以下自定义事件：
- data: 当一端用`write()`发送数据时，另一端会触发data事件，事件传递的数据即是`write()`发送的数据。
- end: 当连接中的任意一端发送了FIN数据时，将会触发该事件。
- connect: 该事件用于客户端，当套接字与服务器连接成功时会被触发。
- drain: 当任意一端调用`write()`发送数据时，当前这端会触发该事件。
- error: 当异常发生时，触发该事件。
- close： 当套接字完全关闭时，触发该事件。
- timeout： 当一定时间后连接不再活跃时，该事件会被触发，通知用户当前该连接已经闲置了。

另外，TCP套接字是可读可写的Stream对象，可以利用`pipe()`方法巧妙地实现管道操作，代码如下：
```javascript
var net = require('net');

var server = net.createServer(function(socket){
    socket.write('Echo server\r\n')
    socket.pipe()
})
```
在node中， 默认开启Nagle算法，可以调用`socket.setNoDelay(true)`去掉Nagle算法，使得`write()`可以立即发生数据到网络中。


## 构建UDP服务
UDP又称用户数据包协议，也属于网路传输层。UDP与TCP最大的不同是UDP不是面向连接的。TCP一旦建立，所有的会话都基于连接完成，客户端如果要与另一个TCP服务通信，需要另创建一个套接字来完成连接。但在UDP中，一个套接字可以与多个UDP服务通信。它虽然提供面向事务的简单不可靠信息传输服务，在网络差的情况下存在丢包严重的问题，但是由于它无须连接，资源消耗低，处理快速且灵活，所以常常用在偶尔丢一两个数据包也不会产生重大影响的场景，比如音频、视频、DNS等。DNS服务即是基于它实现的。

### 创建UDP套接字
UDP套接字一旦创建，既可以作为客户端发生数据，也可以作为服务器接收数据。下面代码创建UDP套接字：
```javascript
var dgram = require('dgram');
var socket = dgram.createSocket('udp4');
```

### 创建UDP服务器端
若想让UDP套接字接收网络消息，只要调用`dgram.bind(post, [address])`方法对网卡和端口进行绑定即可。
```javascript
var dgram = require('dgram');

var server = dgram.createSocket('udp4');

server.on('message', function(msg, rinfo){
    console.log('server got: ' + msg + ' from' + rinfo.address + ':' + rinfo.port);
})

server.on('listening', function(){
    var address = server.address();
    console.log('server listening' + address.address + ':' + address.port);
})

server.bind(41234)
```
该套接字将接收所用网卡上41234端口上的消息。在绑定完成后，将触发listening事件。

### 创建UDP客户端
我们创建一个客户端与服务端进行对话：
```javascript
var dgram = require('dgram');

var message = new Buffer('深入浅出Node.js');
var client = dgram.createSocket('udp4');
client.send(message, 0, message.length, 41234, 'localhost', function(err, bytes){
    client.close();
})
```
当套接字对象用在客户端时，可以调用`send()`方法，[文档](http://nodejs.cn/api/dgram.html#dgram_socket_send_msg_offset_length_port_address_callback)

### UDP套接字事件
UDP套接字只是一个Event Emitter实例，而非Stream的实例。它具备如下自定义事件：
- message： 当UDP套接字侦听网卡端口后，接收到消息时触发该事件，触发携带当数据为消息Buffer对象和一个远程地址信息。
- listening: 当UDP套接字开始侦听时触发事件。
- close： 调用`close()`方法时触发该事件，并不再触发message事件。如需再次触发message事件，重新绑定即可。
- error： 当异常发生时触发该事件，如果不侦听，异常将直接抛出，使进程退出。

## 构建HTTP服务
Node提供基本的http和https模块用于HTTP和HTTPS的封装。
```javascript
var http = require('http');
http.createServer(function(req, res){
    res.writeHead(200, {'Content-type': 'text/plain'});
    res.end('Hello World\n');
}).listen(1337, '127.0.0.1');
console.log('Server running at http://127.0.0.1:1337/');
```

### HTTP模块
Node中，HTTP服务与TCP服务有区别在于：   
开启keep live后，一个TCP会话可以用于多次请求和响应。    
TCP服务以connection为单位进行服务，HTTP服务以request为单位进行服务。http模块即是将connection到request的过程进行封装。

#### 1. HTTP请求
对于TCP连接的读操作，http模块将其封装为ServerRequest对象。
请求行会被`http_parse`解析为`req.method`,`req.url`,`req.httpVersion`属性.       
请求报文头部被解析为`req.headers`。 
请求报名实体则抽象为一个只读流对象，如果业务逻辑需要读取报文体中的数据，则需要在这个数据流结束后才能进行操作。如下
```javascript
function(req, res) {
    var buffers = [];
    req.on('data', function(trunk){
        buffers.push(thrunk);
    }).on('end', function(){
        var buffer = Buffer.concat(buffers);
        //TODO
        res.end('Hello world');
    });
}
```
#### 2. HTTP响应
HTTP响应封装流对底层连接对写操作，可以将其看成一个可写对流对象。    
`res.setHeader()`,`res.writeHead()`用于设置响应报文头部。   
`res.write()`,`res.end()`用于设置响应报文实体。 

#### 3. HTTP服务事件
HTTP服务器也是一个EventEmitter实例，也抽象一些事件，以供应用层使用。
- connection: [文档](http://nodejs.cn/api/http.html#http_event_connection)
- request: [文档](http://nodejs.cn/api/http.html#http_event_request)
- close: [文档](http://nodejs.cn/api/http.html#http_server_close_callback)
- checkContinue: [文档](http://nodejs.cn/api/http.html#http_event_checkcontinue)
- connect: [文档](http://nodejs.cn/api/http.html#http_event_connect_1)
- upgrade: [文档](http://nodejs.cn/api/http.html#http_event_upgrade_1)
- clientError: [文档](http://nodejs.cn/api/http.html#http_event_clienterror)

### HTTP客户端
`http.request(options, connect)`，用于构造HTTP客户端。
```javascript
var options = { 
    hostname: '127.0.0.1', 
    port: 1334,
    path: '/',
};
var req = http.request(options, function(res) { 
    console.log('STATUS: ' + res.statusCode); 
    console.log('HEADERS: ' + JSON.stringify(res.headers)); res.setEncoding('utf8');
    res.on('data', function (chunk) { 
        console.log(chunk);
    }); 
});
req.end();
```
options参数决定了这个HTTP请求头中的内容，[文档](http://nodejs.cn/api/http.html#http_http_request_options_callback).     

#### 1. HTTP代理
和服务器端的实现一样，http提供的`ClientRequest`对象也是基于TCP层实现的。在keeplive的情况下，一个底层会话连接可以多次用于请求。为了重用TCP连接，http模块包含一个默认的客户端代理对象`http.globalAgent`。它对每个服务端（host + port）创建的连接进行了管理，默认情况下，通过`ClientRequest`对象对同一个服务器端发起对HTTP请求最多可以创建5个连接。在options中可以设置自定义的agent对象，解除默认连接限制。    

#### 2. HTTP客户端事件
与服务队对应，HTTP客户端也有相应的事件：
- response: [文档](http://nodejs.cn/api/http.html#http_event_response)
- socket: [文档](http://nodejs.cn/api/http.html#http_event_socket)
- connect: [文档](http://nodejs.cn/api/http.html#http_event_connect)
- upgrade: [文档](http://nodejs.cn/api/http.html#http_event_upgrade)
- continue: [文档](http://nodejs.cn/api/http.html#http_event_continue)  

## 构建WebSocket服务
Node与WebSocket协议是绝配：
- WebSocket客户端基于事件的编程模型与Node的自定义事件相差无几；
- WebSocket实现了客户端与服务端之间的长连接，而Node事件驱动的方式十分擅长与大量的客户端保持高并发连接。

WebSocket与传统HTTP有如下好处：
- 客户端与服务端只建立一个TCP连接，更少的连接请求；
- WebSocket服务器可以推送数据到客户端；
- 更轻量级的协议头，减少数据传送量。    

WebSocket在客户端的应用示例：
```javascript
var socket = new WebSocket('ws://127.0.0.1:12010/updates');
socket.onopen = function(){
    setInterval(function(){
        if(socket.bufferedAmount === 0) {
            socket.send(getUpdateData());
        }
    }, 50);
};

socket.onmessage = function(event) {
    //TODO
};
```
WebSocket协议主要分为：握手和数据传输。     
WebSocket是在TCP上定义独立的协议，但是WebSocket的握手部分是有HTTP完成的。

### WebSocket握手
客户端建立连接时，通过HTTP发起请求报文，如下：
```
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ== Sec-WebSocket-Protocol: chat, superchat Sec-WebSocket-Version: 13
```