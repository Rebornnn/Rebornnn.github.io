---
title: 前端面试总结
date: 2019-10-29 18:05:10
categories:
- 面试
tags:
- 前端
- 面试
- 学习
- 指南
description: 主要针对前端面试内容、面试技巧的总结
---
# 前端基础
## HTML基础
### DOCTYPE的作用是什么？
html5标准网页声明，告知浏览器的解析器用什么文档标准解析文档，不同的渲染模式会影响到css甚至js的脚本解析。必须声明在第一行。
文档解析类型：
- 标准模式：W3C标准
- 怪异模式： 浏览器自己标准


## CSS基础
### CSS选择器的优先级是怎么样的？
内联 > id选择器 > 类选择器 > 标签选择器， 权重从左到右依次减小。

### link和@import区别？
- link是xhtml元素，@import是css提供的(需要IE5以上)
- 页面加载时，link会同时被加载；@import引用的css等到页面加载完再加载
- link的样式权重高于@import

### 如何理解z-index？
css中的z-index属性控制重叠元素的垂直叠加顺序，默认元素的z-index为0，修改z-index来控制元素的图层位置，而且z-index仅在定位元素(position不等于static)中生效。

### 如何理解层叠上下文？
#### 是什么？
层叠上下文是HTML元素的三维概念，这些HTML元素在一条假想的相对于面向用户的z轴上叠放排列，HTML元素依据其自身优先级顺序占用层叠上下文的空间。
#### 作用是什么？
该元素的所有后代元素相对于该祖先元素都有其自己的叠放顺序。
#### 如何产生?
触发一下条件则会产生层叠上下文:
- 根元素(HTML)
- z-index 值不为 "auto"的
- opacity 属性值小于 1 的元素（参考 the specification for opacity），
- transform 属性值不为 "none"的元素
- mix-blend-mode 属性值不为 "normal"的元素，
- filter值不为“none”的元素,
- perspective值不为“none”的元素，
- isolation 属性被设置为 "isolate"的元素，
- position: fixed
- 在 will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值
- webkit-overflow-scrolling 属性被设置 "touch"的元素

### 你对盒模型的理解？
#### 是什么？
当一个文档进行布局的时候，浏览器的渲染引擎会根据标准盒模型将所有元素渲染为一个矩形盒子。CSS决定盒子的大小、位置、颜色、背景、边框····
盒模型由content、padding、border、margin组成。  
#### box-sizeing: content-box border-box

### 谈谈对BFC的理解？
#### 是什么？
BFC是块级格式上下文，页面中一个独立的渲染区域，让处于内部的元素与外部的元素互相隔离。
#### 如何形成？
- 根元素
- position不为static
- float不为none
- overflow不为visible
- display: inline-block table-cell table-caption
#### 作用是什么？
- 防止margin重叠
- 消除浮动的副作用
    - 防止文字环绕
    - 防止高度坍塌


### 伪类和伪元素的区别是什么？
#### 是什么？
伪类（pseudo-class） 是一个以冒号(:)作为前缀，被添加到一个选择器末尾的关键字，当你希望样式在特定状态下才被呈现到指定的元素时，你可以往元素的选择器后面加上对应的伪类。

伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过::before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。

#### 区别
伪类是通过在元素选择器上加入伪类改变元素状态，而伪元素通过对元素的操作进行对元素的改变。    

## js基础

### js的作用域链理解吗？
js是词法作用域(静态作用域)，声明的作用域在编译阶段就已经确定。      
js在执行时会创建执行上下文，执行上下文中的词法环境会包含外层词法环境的引用，通过引用可以获取外层词法环境的变量，这些引用层层串联最终指向全局环境，因此形成作用域连。s

### ES6 模块与 CommonJS 模块的差异
两个重大差异： 
- CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值的引用
- CommonJS模块是运行时加载，ES6模块是编译时输出接口

### 为什么会有BigInt的提案？
`Number.MAX_SAFE_INTEGER`，表示最大安全数字

### 0.1 + 0.2 为什么不等于0.3?
JS的Number类型是双精度浮点数，遵循IEEE 754标准。    

以0.1转换IEEE 754标准为例，会有3个阶段：
- 0.1转换为二进制表示
- 二进制用科学计数法表示
- 科学计数法表示的二进制转换为IEEE 754标准表示
问题出在第三步，以IEEE 754标准转换后的0.1换成十进制，变成0.100000000000000005551115123126


### 谈谈你对原型链的理解？
#### 先谈原型对象
绝大部分函数(少数内建函数除外)都会有一个prototype属性，这个属性指向函数的原型对象，当调用构造函数创建实例时,该实例的内部将包含一个内部`__proto__`属性，指向构造函数的原型对象。所有被创建的实例都会共享原型对象，这些实例可以访问原型对象的属性。

#### 原型链
原因是每个对象都有`__proto__`属性，此属性指向该对象的构造函数的原型。   
对象可以通过`__proto__`与上游的构造函数的原型对象连接起来，而上游的原型对象也有一个`__proto__`，这样形成了原型链。


### 谈谈你对原型链的理解？
this的指向不是在编写时确定的，而是在执行时确定的，同时，this的指向遵循一定的规则。
- 默认规则，指向全局对象
- 隐式调用，函数被调用的位置存在上下文对象时，指向这个上下文对象
- 显示调用(apply, call, bind)，指向指定的对象
- new调用，优先级最高，用 new 调用一个构造函数，会创建一个新对象,this会自动绑定到这个新对象


> 补充  
箭头函数与传统函数的差异：  
> - 没有`this`、`super`、`new.target`绑定  它们的值由外围最近一层非箭头函数决定。
> - 不能通过`new`调用  箭头函数没有`[[Construct]]`方法，所以不能被用作构造函数
> - 没有原型
> - 不支持`arguments`对象
> - 不支持重复的命名参数

### async/await是什么？
async函数，就是Generator函数的语法糖，它建立在Promise上，并且与所有现有的Promise的API兼容。
1. Async——声明一个异步函数
- 自动将常规函数转换为Promise，返回值也是一个Promise对象
- 只有asyn函数内部的异步操作执行完，才会执行then方法指定的回调函数
- 异步函数内部可以使用await

2. Await——暂停异步的功能执行
- 放置在Promise调用之前，await强制代码等待，直到Promise完成并返回结果
- 只能与Promise一起使用，不适用回调
- 只能在async函数内调用




## 浏览器与新技术
### 浏览器是如何渲染UI的？
1. 浏览器获取HTML文件，然后对文件进行解析，形成DOMTree
2. 与此同时，进行CSS解析，形成Style Rules
3. 接着将DOMTree和Style Rules合成为Render Tree
4. 然后进入布局(layout)阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标
5. 随后调用GPU进行绘制(Paint)，遍历Render Tree的节点，并将元素呈现出来

![](http://img.aisss.top/FlF6psiOOHwpRxNcr2l_tS4jeJ3A)


### DOM Tree是如何建立的？
1. 转码：浏览器将接收到的二进制数据按照指定编码格式转化为HTML字符串
2. 生成TOKEN：浏览器会将HTML字符串解析成Tokens
3. 构建Nodes：对Node添加特定的属性，通过指针确定Node的父、子、兄弟关系和所属treeScope
4. 生成Dom Tree: 通过node包含的指针确定的关系构建出DOM Tree

![](http://img.aisss.top/FvPGXe41Vk8T5pOsWFMIEbWEnze5)




# 前端基础笔试
## javascript笔试部分
### 实现防抖函数(debounce)
```javascript
//计时器版本
const debounce = (fn, ms = 0) => {
    const timer = null;
    return (..args) => {
        clearTimer(timer);
        timer = setTimeout(() => {
            fn.apply(this, args)
        }, ms)
    }
}
// 时间差版本
const debounce = (fn, delay) => {
    let last = 0;
    
    return (...args) => {
        let now = Date.now();
        if(now - last >= delay) {
            fn.apply(this, args)
        }
        last = now;
    }
}
```

### 实现节流函数(throttle)
```javascript
//计时器版本
const throttle = (fn, delay) => {
    let timer = null;

    return (..args) => {
        if(timer) return;
        timer = setTimeout(() => {
            fn.apply(this, args);
            timer = null;
        }, delay)
    }
}

//简易版，在delay时间内只执行一次
const throttle = (fn, delay) => {
    let last = 0;
    return (..args) => {
        if(now - last >= delay) {
            last = now;
            fn.apply(this, args);
        }
    }
}

//升级版，时间间隔小于delay时设置一个定时器
const throttle = (fn, delay) => {
    let last = 0;
    let timer = null; 

    return (..args) => {
        if(now - last >= delay) {
            last = now;
            fn.apply(this, args)
        } else {
            clearTimeout(timer);
            timer = setTimeout(() => {
                last = now;
                fn.apply(this, args)
            }, delay)
        }
    }
}

```