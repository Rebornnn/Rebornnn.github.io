---
title: 防抖与节流函数
date: 2019-07-18 14:17:18
categories:
- 前端
- 面试
tags:
- javascript
- 防抖
- 节流
description: 深入原理
---
## 函数防抖
```javascript
const debounce = (fn, ms = 0) => {
    let timer = null;
    
    return function(...args){
        clearTimeout(timer);
        timer = setTimeout(() => {
            fn.apply(this,args);
        },ms);
    }
}
```
## 函数节流
```javascript
//简易版，在delay时间内只执行一次
const throttle = (fn, delay) => {
    let last = 0;
    
    return function() {
        let now = Date.now();
        
        if(now - last >= delay) {
            last = now;
            fn.apply(this, arguments);
        }
    }
}

//升级版，在简易版基础上，如果时间间隔小于delay，则会设置一个新的定时器
//节流+防抖结合体
const throttle = (fn, delay) => {
    let last = 0;
    let timer = null;
    
    return function() {
        let self = this;
        let args = arguments;
        let now = Date.now();
        
        if(now - last < delay) {
            clearTimeout(timer);
            timer = setTimeout(()=>{
                last = now;
                fn.apply(self, args);
            },delay)
        } else {
            last = now;
            fn.apply(self, args);
        }
    }
}

//另一个版本throttle
var throttle = function(fn, interval) {
    var timer = null;
    var firstTime = true;
    
    return function(){
        var self = this;
        var args = arguments;
        
        if(firstTime) {
            fn.apply(self, args);
            return firstTime = false;
        }
        
        if(timer) {      //如果定时器还在，说明前一次延迟执行还没完成
            return false;
        }
        
        timer = setTimeout(function(){
            clearTimeout(timer);
            timer = null;
            fn.apply(self, args);
        }, interval)
    }
}

//30 seconds版本
const throttle = (fn, wait) => {
    let inThrottle, timer, last;
    
    return function() {
        let self = this;
        let args = arguments;
        let now = Date.now();
        
        if(!inThrottle) {
            fn.apply(self, args);
            inThrottle = true;
            last = now;
        } else {
            clearTimeout(timer);
            timer = setTimeout(()=>{
                if(now - last >= wait) {
                    fn.apply(self, args);
                    last = now;
                }
            }, Math.max(wait - (now - last) ,0))
        }
    }
}
```
