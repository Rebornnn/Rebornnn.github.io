---
title: 《深入浅出node.js》读书笔记3-1异步编程
date: 2019-08-01 16:15:25
categories:
- 读书笔记
- 《深入浅出node.js》
tags:
- node
- 系统学习
description: 异步编程范式
---
## 函数式编程
函数式编程是Javascript异步编程的基础。

### 高阶函数
通常的语言中，函数的参数只接受基本的数据类型或是对象引用，返回值也只是基本数据类型和对象引用。      
高阶函数在Javascript中比比皆是，一些复杂业务逻辑的解耦，受益于高阶函数。    

### 偏函数用法
偏函数： 指定部分参数来产生一个新的定制函数的形式。
```Javascript
//例子
var toString = Object.prototype.toString();

var isString = function() {
    return toString.call(obj) == '[object String]';
};

var isFunction = function() {
    return toStrinf.call(obj) == '[object Function]';
}

//使用偏函数后
var isType = function(type) {
    return function(obj) {
        return Object.prototype.toString.call(obj) == '[object ' + type + ']';
    }
}

var isString = isType('String');
var isFunction = isType('Function');
```

## 异步编程的优势与难点
### 优势
1、基于事件驱动的非阻塞I/O模型，在分布式和云服务上的高并行使得各个单点之间能够更有效的组织起来。
2、Node的V8引擎能够调用C/C++扩展模块，性能可以逼近C语言。
3、合理利用Node的异步模型与V8的高性能，就可以充分发挥CPU和I/O资源的优势。

### 难点

#### 1、难点1:异常处理
`tray/catch`失效：      
异步I/O实现主要包含两个阶段：提交请求和处理结果。这两个阶段中间有事件循环的调度，两者彼此不关联。异步方法则通常在第一个阶段提价请求后立即返回，因为异常并不一定发生在这个阶段，`tray/catch`功效在此处不会发挥任何作用。     
Node在处理异常上形成一种约定：**将异常作为回调函数的第一个实参传回，如果为空值，则表明异步调用没有异常抛出**
```javascript
async(function(err, result){
    //TODO
})
```
我们自行编写的异步方法上，也需要去遵循一些原则：    
- 原则一： 必须执行调用者传入的回调函数；
- 原则二：正确传递回异常供调用者判断。
示例代码如下：
```javascript
var async = function(callback){
    process.nextTick(function(){
        var result = something;
        if(error) {
            return callback(error);
        }
        callback(null, result);
    })
}
```

#### 2、难点2:函数嵌套过深
Node中多个异步调用的场景比比皆是。

#### 3、难点3:多线程编程
`child_process`是多线程编程的基础API，`cluster`模式是更深层次的应用，在第九章详细展开。

#### 4、难点4:异步转同步
Node中的同步式编程，需要借助库或者编译等手段来实现。


## 异步编程解决方案
异步编程的主要解决方案有3种：
- 事件发布/订阅模式
- Promise/Deferred模式
- 流程控制库


### 事件发布/订阅模式
事件监听器模式是一种广泛用于异步编程的模式，是回调函数的事件化，又称发布/订阅模式。
```javascript
//订阅
emitter.on('event1', function(message){
    console.log(message)
})；
// 发布
emitter.emit('event1', 'i am message')；
```
事件发布/订阅模式可以实现一个事件与多个回调函数的关联，这些回调函数又称为事件侦听器。       
Node对事件发布/订阅的机制做了健壮性处理：
- 如果对一个事件添加了超过10个侦听器，将会得到一个警告。调用`emitter.setMaxListeners(0)`可以去掉限制。
- EvenEmitter对象对error事件进行了特殊对待.如果没有为 'error' 事件注册监听器，则当 'error' 事件触发时，会抛出错误、打印堆栈跟踪、并退出 Node.js 进程。

#### 利用事件队列解决雪崩问题
雪崩问题：  
在高访问量、大并发量大情况下缓存失效大情景，此时大量大请求同时涌入数据库中，数据库无法同时承受如此大的查询请求，进而往前影响到网站整体的响应速度。      
以下是一条数据库查询语句的调用：
```javascript
var select = function(callback) {
    db.select('SQL', function(results) {
        callback(results)
    });
};
```
如果站点刚好启动，这时缓存中是不存