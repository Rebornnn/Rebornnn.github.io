---
title: 《深入浅出Node.js》读书笔记8-1玩转进程
date: 2019-10-11 18:26:48
categories:
- 读书笔记
- 《深入浅出node.js》
tags:
- node
- 系统学习
description: 进程
---
Node在选型时决定在V8引擎之上构建，它和浏览器类似，运行在单个进程的单个线程上。好处是：程序状态是单一的，在没有多线程的情况下没有锁、线程同步问题，操作系统在调度时也因为较少上下文的切换，可以很好的提高CPU的使用率。   
同时带来两个缺点：
- CPU利用率
- 进程的健壮性

## 服务器的变迁
同步➡复制进程➡多线程➡事件驱动

## 多进程架构
![](http://img.aisss.top/Fn36wnr4FUXVwwbmg3RQT1smaBAT)      
上图是著名的Master-Worker模式，又称主从模式。主进程不负责具体的业务处理，而是负责调度或管理工作进程，工作进程负责具体的业务处理。


### 创建子进程
`child_process`模块提供了4个方法用于创建进程：
- `spawn()`: 启动一个子进程来执行命令
- `exec()`: 启动一个子进程来执行命令，与`spawn()`不同的是其接口不同，它有一个回调函数获知子进程的状况。
- `execFile()`: 启动一个子进程来执行可执行文件
- `fork()`: 与`spawn()`类似，不同点在于它创建的Node的子进程只需指定要执行的javascript文件模块即可。     

![](http://img.aisss.top/Fj6ptqqAh7F1bQ1FDzJyVLK50cK2)          
> 可执行文件：可以直接执行的文件，如果是javascript文件，它的首行内容必须添加如下代码
```
#!/usr/bin/env node
```

### 进程间通信
在Master-Worker模式中，要实现主进程管理工作和调度工作进程的功能，需要主进程和工作进程之间的通信。对于child_process模块，创建好了子进程，然后与父子进程间通信是十分容易的。  
子进程对象则由`send()`方法实现主进程向子进程发送数据，message事件实现收听子进程发来的数据。通过消息传递内容，而不是共享或直接操作相关资源，这是较为轻量和无依赖的做法。
```javascript
// parent.js
var cp = require('child_process');
var n = cp.fork(__dirname + '/sub.js');

n.on('message', function (m) { 
    console.log('PARENT got message:', m);
});
n.send({hello: 'world'});

// sub.js
process.on('message', function (m) { 
    console.log('CHILD got message:', m);
});

process.send({foo: 'bar'});
```

#### 进程间通信原理
IPC的全称是Inter-Process Communication, 即进程间通信。进程间通信的目的是为了让不同的进程能够互相访问资源并进行协调工作。Node实现IPC通道由libuc实现。示意图如下  
![](http://img.aisss.top/FpinvtRuB65g0cCdOUOc-NATBGkf)      
父进程在实际创建子进程之前，会创建IPC通道并监听它，然后才真正创建子进程，并通过环境变量（NODE_CHANNEL_FD）告诉子进程这个IPC通道的文件描述符。子进程在启动的过程中，根据文件描述符去连接这个已存在的IPC通道，从而完成父子进程之间的连接。下图为IPC管道的步骤示意图   
![](http://img.aisss.top/FtPVAxDwfDXHbKIK7BomLGYCvftK)  

### 句柄传递
什么是句柄？句柄是一种可以用来标识资源的引用，它的内部包含了指向对象的文件描述符。比如句柄可以用来标识一个服务器端socket对象、一个客户端socket对象、一个UDP套接字、一个管道。   
主进程接收到socket请求后，将这个socket直接发送给工作进程，而不是重新与工作进程之间建立新的socket连接来转发数据。主进程代码如下：
```javascript
// parent.js
var cp = require('child_process');
var child1  = cp.fork('child.js');
var child2  = cp.fork('child.js');

var server = require('net').createServer();
server.on('connection', function(socket) {
    socket.end('handle by parent\n')
})
server.listen(1337, function(){
    child1.send('server', server); 
    child2.send('server', server);
})
```
子进程代码如下：
```javascript
process.on('message', function(m, server){
    if(m === 'server') {
        server.on('connection', function(socket){
            socket.end('handled by child, pid is ' + process.pid + '\n')
        })
    }
})
```
测试的结果是每次出现的结果都可能不同，结果可能被父进程处理，也可能被不同的子进程处理。并且这是在TCP层面上完成的事情，我们尝试转化到HTTP层面来试试。对于主进程，将服务器句柄发送给子进程之后就可以关掉服务器的监听，让子进程来处理。父进程改动如下：
```javascript
// parent.js
var cp = require('child_process');
var child1  = cp.fork('child.js');
var child2  = cp.fork('child.js');

var server = require('net').createServer();
server.listen(1337, function(){
    child1.send('server', server); 
    child2.send('server', server);

    server.close();
})
```
子进程改动如下：
```javascript
var http = require('http');
var server = http.createServer(function(req,res){
    res.writeHead(200, {'Content-Type': 'text/plain'});
    res.end('handled by child, pid is ' + process.pid + '\n')
})

process.on('message', function(m, tcp){
    if(m === 'server') {
        tcp.on('connection', function(scoket){
            server.emit('connection', socket)
        })
    }
})
```
这样一来，所有的请求都是由子进程处理。整个过程中，服务的过程发生了一次改变，如图    
![](http://img.aisss.top/Fpr6cj2RRkeIUwkDlfdCPEOImqxz)      
主进程发生完句柄并关闭监听之后，成为如下图结构      
![](http://img.aisss.top/FpsCyMc7MUW1jOHRt1je_JwkrDsr)

#### 1. 句柄发生与还原
句柄发送跟我们直接将服务器对象发送给子进程有没有差别？      
它是否真的将服务器对象发送给子进程？        
为什么它可以发送到多个子进程中？    
发送给子进程为什么父进程中还存在这个对象？  

目前子进程对象`send()`方法可以发送的句柄类型包括如下
- net.Socket TCP套接字
- net.Server TCP服务器，任意建立在TCP服务上的应用层服务都可以享受到它带来的好处
- net.Native C++层面的TCP套接字或IPC管道
- dgram.Socket UDP套接字
- dgram.native C++层面的UDP套接字   

`send()`方法在将消息发送到IPC管道前，将消息组装成两个对象，一个参数是handle，另一个是message。      
![](http://img.aisss.top/FhFxPbpET3YVlt38tXT5316xLGAP)      
以发送的TCP服务器句柄为例，子进程收到消息后的还原过程如下：
```javascript
function(message ,handle, emit) {
    var self = this;

    var server = new net.Server();
    server.listen(handle, function(){
        emit(server);
    })
}
```

#### 2. 端口共同监听
为何通过发送句柄后，多个进程可以监听到相同的端口而不引起EADDRINUSE(端口占用)异常？      
因为独立启动的进程中，TCP服务器端socket套接字的文件描述符并不相同，导致监听到相同的端口时会抛出异常。但对于`sned()`发送的句柄还原出来的服务而言，它们的文件描述符是相同的，所以监听相同的端口不会引起异常。     
多个应用监听相同的端口时，文件描述符同一时间只能被某个进程所用。换言之，网络请求向服务器发送时，只有一个幸运的进程能够抢到连接，也就是说只有它能为这个请求进行服务。    

## 集群稳定之路
搭建好Node集群，充分利用多核CPU资源，还有一些细节需要考虑：
- 性能问题
- 多个工作进程的存活状态管理
- 工作进程的平滑启动
- 配置或者静态数据的动态重新载入
- 其他细节

虽然我们创建了很多工作进程，但每个工作进程依然是在单线程上执行，它的稳定性还不能得到完全的保障。我们需要建立一个健全的机制来保障Node应用的健壮性。  

### 进程事件
